**Task Engine · Day 3**  
  
主题：状态流转（State Transition）与受控更新（Controlled Mutation）  
  
⸻  
  
**Day 3 的核心目标**  
  
Day 3 的目标不是“让 Task 能被修改”，  
而是 **定义 Task 在什么条件下允许变化，以及什么变化是非法的**。  
  
从 Day 3 开始，系统不仅知道什么是合法的 Task，  
还知道 **Task 如何合法地演变**。  
  
⸻  
  
**Day 3 的工程成果概述**  
  
1）实现了受控的更新 API  
	•	更新 title / note / dueAt / tags 不再是直接赋值  
	•	所有修改都通过明确的方法完成  
	•	每一次更新都会返回一个新的 Task（值语义）  
  
2）实现了受控的状态流转  
	•	pending → completed / archived  
	•	completed → pending / archived  
	•	archived → 任何状态（不允许）  
  
3）建立了“归档即冻结”的不可逆规则  
	•	archived 状态下，任何更新都会被系统拒绝  
	•	拒绝方式是抛出明确的业务错误（taskIsArchived）  
  
⸻  
  
**状态与更新的设计原则**  
  
**1）值语义更新（Value Semantics）**  
  
Task 是值类型（struct），因此：  
	•	不在原对象上直接修改  
	•	每次更新都返回一个新的 Task  
	•	调用者显式接收新的状态  
  
这种设计方式：  
	•	符合 Swift / SwiftUI 的数据流模型  
	•	避免隐式共享状态  
	•	让变化路径清晰、可追踪  
  
⸻  
  
**2）受控更新，而非自由修改**  
  
Task 的字段不再是“谁都能改”，  
而是：  
	•	只能通过系统定义好的 API 修改  
	•	修改前必须通过规则校验  
	•	修改失败会被明确拒绝，而不是 silently ignore  
  
这是系统稳定性的关键。  
  
⸻  
  
**归档（archived）的工程含义**  
  
归档不是一个普通状态，而是 **最终态（final state）**：  
	•	一旦进入 archived  
	•	所有更新操作都将失败  
	•	系统通过 taskIsArchived 明确拒绝  
  
这条规则在系统层面被强制执行，而不是依赖调用者自觉。  
  
⸻  
  
**Day 3 中的错误建模认知**  
  
在 Day 3 中，以下情况被视为**正常的业务失败**：  
	•	修改已归档任务  
	•	非法状态流转  
	•	不符合更新规则的输入  
  
这些失败：  
	•	不会导致 crash  
	•	不会污染系统状态  
	•	会通过 throws 明确返回给调用者  
  
这是成熟系统应有的行为。  
  
⸻  
  
**关于 self 与 Self 的理解（Day 3 衍生认知）**  
  
**self：当前实例**  
	•	self 代表“当前这个 Task 实例”  
	•	在值类型中，self 表示当前值  
	•	var copy = self 是对当前值的显式复制  
  
self 是实例级概念，用于描述“我是谁”。  
  
⸻  
  
**Self：当前类型**  
	•	Self 代表“调用该方法的具体类型”  
	•	是类型级别的占位符  
	•	用于支持未来的扩展与继承场景  
  
Self 描述的是“我属于什么类型”，而不是某个具体实例。  
  
⸻  
  
**关于值类型（struct）与引用类型（class）的工程判断**  
  
在 Day 3 的实践中，进一步明确了以下判断原则：  
  
**使用 struct 的场景**  
	•	描述业务数据本身（Domain Model）  
	•	UI 展示的数据快照  
	•	不需要共享身份的状态  
	•	复制是合理且安全的  
  
Task 属于典型的值类型建模对象。  
  
⸻  
  
**使用 class 的场景**  
	•	需要共享状态或副作用  
	•	具有明确生命周期  
	•	多处需要观察同一个变化  
	•	复制在现实语义中不合理  
  
例如：  
	•	ViewModel  
	•	网络服务  
	•	全局管理器  
	•	与后端通信的 API Client  
  
⸻  
  
**一句话总结类型选择原则**  
  
**struct 用来描述世界的“状态”，**  
**class 用来驱动世界的“行为”。**  
  
⸻  
  
**Day 3 阶段性结论**  
  
如果 Day 1 是定义世界的结构，  
Day 2 是定义世界的边界，  
那么 Day 3 是定义世界如何在规则内变化。  
  
从这一天开始：  
	•	Task 不是一个“随意可变”的数据结构  
	•	而是一个 **受系统规则保护的领域对象**  
  
这为后续更复杂的状态机、并发安全、UI 绑定打下了坚实基础。  
  
⸻  
  
****底层机制补充理解****  
主题：Copy-on-Write · 深浅拷贝 · ARC  
  
为什么 Day 3 中“返回新的 Task”不会造成性能问题？  
  
Day 3 的设计采用了值语义更新：  
每次更新都会返回一个新的 Task，而不是在原对象上直接修改。  
这一设计之所以在工程上可行，是因为 Swift 在底层通过三套机制协同支撑：  
  
1）Copy-on-Write（写时复制）  
2）浅拷贝与深拷贝策略  
3）ARC（自动引用计数）  
  
————————  
  
一、什么是 Copy-on-Write（写时复制，COW）  
  
Copy-on-Write 的核心思想是：  
看起来在复制，实际上先共享；只有在“真的要写”的那一刻，才进行真正的复制。  
  
在 Task 更新过程中，当一个 Task 被赋值给另一个变量时：  
  
语义层面：  
两个 Task 是完全独立的值。  
  
底层实现层面：  
小型值（如 enum、Date、UUID）直接复制；  
String、Set 等较大的数据结构会先共享同一块内存缓冲区。  
  
当后续发生写入操作（例如修改 title、tags）时，  
Swift 会检测这块内存是否为“独占”。  
如果不是独占，才会在写入前复制一份新的缓冲区。  
  
因此结果是：  
对外表现为值语义安全，  
对内实现为最小化复制成本。  
  
————————  
  
二、什么是浅拷贝与深拷贝  
  
浅拷贝（Shallow Copy）的特点是：  
只复制引用，不复制数据内容本身；  
多个变量指向同一份数据；  
修改一处，其他引用可能同时感知变化。  
这是引用类型（class）的默认行为。  
  
深拷贝（Deep Copy）的特点是：  
复制引用的同时，也复制实际数据；  
不同副本之间完全独立；  
修改互不影响，但成本较高。  
  
Swift 的值类型并不总是浅拷贝或深拷贝，  
而是采用一种折中策略：  
读取时共享，写入时自动分离。  
这正是 Copy-on-Write 的具体体现。  
  
————————  
  
三、什么是 ARC（Automatic Reference Counting）  
  
ARC 是 Swift 用于管理引用类型内存生命周期的机制。  
  
需要明确的是：  
ARC 直接管理的是 class 实例，  
而不是 struct 本身。  
  
ARC 的工作方式是：  
每一个 class 实例都维护一个引用计数；  
有新的引用指向它时，计数加一；  
引用断开时，计数减一；  
当计数归零，对象会被释放，内存被回收或复用。  
  
ARC 是确定性的内存管理机制，而不是垃圾回收。  
  
————————  
  
ARC 与 Task（struct）的关系  
  
虽然 Task 是值类型，  
但其内部的 String、Set 等数据结构，  
底层依赖堆上的引用对象（缓冲区）。  
  
这些缓冲区对象正是由 ARC 管理的。  
  
当某个旧 Task 不再被任何变量持有时：  
其内部缓冲区的引用计数会递减；  
若计数归零，ARC 会释放对应的内存资源。  
  
————————  
  
四、三者在 Day 3 中的协同效果  
  
在一次 Task 更新过程中：  
  
语义层面：  
调用者显式接收一个新的状态值。  
  
Copy-on-Write 层面：  
如果发生写入且存在共享，才进行真实复制。  
  
ARC 层面：  
旧值若不可达，其内部引用资源被回收。  
  
最终实现的效果是：  
语义上不可变、状态清晰；  
实现上共享优先、复制最小化。  
  
————————  
  
本节总结  
  
Copy-on-Write 让值语义既安全又高效；  
Swift 在浅拷贝与深拷贝之间动态取得平衡；  
ARC 负责回收无人再使用的引用资源。  
  
这三者共同支撑了 Day 3 中“值语义更新”的工程可行性。  
